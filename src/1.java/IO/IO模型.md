# Unix I/O模型
## 1. Unix IO模型
unix的IO模型分为5种
- 阻塞式IO
- 非阻塞式IO
- IO多路复用
- 信号驱动式IO
- 异步IO

另外有两大分类
- 阻塞：发起请求后内核没准备好线程都挂起等待结果；在IO场景下调用recvfrom后等待os将数据拷贝到用户空间是为阻塞
- 非阻塞：发起请求后如果内核没准备好线程不挂起，可以执行其他动作；；在IO场景下调用recvfrom后让os立即返回，之后一直轮询直到最后一次调用请求数据拷贝是非阻塞

- 同步：关注获取数据的方式，内核准备好后是被用户从内核态拉取到用户态的。因此上述两种方式皆为同步
- 异步：内核准备好后回调一个处理线程：发起io请求的线程直接注册一个监听，os负责拷贝数据到用户态完成通知监听线程执行操作
（监听线程可能是一个线程池，那么AIO和线程池之间会通过一个等待队列实现生产消费，不会造成无限膨胀）。 Linux下不支持这种方式，windows有IOCP。
另外，采用异步模式时也无需发起线程来等待了，因此一般没有阻塞异步的情况。

### 1.1 阻塞同步IO
![阻塞式IO.png](..%2Fimage%2F%E9%98%BB%E5%A1%9E%E5%BC%8FIO.png)
### 1.2. 非阻塞同步IO
![非阻塞式IO.png](..%2Fimage%2F%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%BC%8FIO.png)
### 1.3. 异步IO
![异步IO.png](..%2Fimage%2F%E5%BC%82%E6%AD%A5IO.png)
proactor模型就是基于os提供的aio基础上进行的面向对象的封装。



**---以下和上面的概念呈现正交关系---**
### 1.4. IO多路复用(或者叫时分复用）
![IO复用.png](..%2Fimage%2FIO%E5%A4%8D%E7%94%A8.png)
使**单个进程具有处监听多个连接**的 I/O 事件的能力。从os层面的select、poll、epoll来看，他们都应该是阻塞或非同步（例如epoll_wait可以让他阻塞或者是立即返回）
高性能网络模型中的reactor模式就是基于os层面上的多路复用。


### 1.5. TBD 信号驱动式IO
![信号驱动IO.png](..%2Fimage%2F%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8IO.png)
可见类似于多路复用的流程，不过是通过信号来通知进程的。应该是同步阻塞或非阻塞模型。